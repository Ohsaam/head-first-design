# Ch 13. 실전 디자인 패턴

## 디자인 패턴의 정의

패턴(Pattern)은 특정 **컨텍스트** 내에서 주어진 **문제**의 **해결책**이다.

컨텍스트(Context)란 패턴이 적용되는 상황을 뜻한다. **반복적**으로 일어날 수 있는 상황이어야만 한다.
문제(Problem)란 컨텍스트 내에서 **이뤄야 하는 목표**를 뜻한다. 여기에는 컨텍스트 내의 제약조건도 포함한다.
해결책(Solution)이 바로 우리가 찾아내햐 하는 것이다. 제약조건 속에서 누가 적용해도 목표를 이룰 수 있는 일반적인 디자인을 뜻한다.


-> 어떤 컨텍스트 내에서 일련의 제약조건에 의해 영향을 받는 문제가 발생했다면, 
그 제약조건 내에서 목적 달성을 위한 해결책이 되는 디자인을 적용하면 된다.


## 디자인 패턴 분류

분류 방법 1) 생성 패턴, 행동 패턴, 구조 패턴

생성 패턴(Creational Pattern)

정의) 객체 인스턴스를 생성하는 패턴으로 클라이언트와 그 클라이언트가 생성해야 하는 객체 인스턴스 사이의 연결을 끊어 주는 패턴이다.
패턴) 싱글턴, 추상 팩토리, 팩토리 메소드, 빌더, 프로토 타입

행동 패턴(Behavioral Pattern)

정의) 클래스와 객체들이 상호작용하는 방법과 역할을 분담하는 방법을 다루는 패턴이다.
패턴) 템플릿 메소드, 싱글턴, 반복자, 옵저버, 상태, 전략, 중재자, 비지터, 메멘토, 인터프리터, 역할 변경

구조 패턴(Structural Pattern)

정의) 클래스와 객체를 더 큰 구조로 만들 수 있게 구성을 사용하는 패턴이다.
패턴) 데코레이터, 프록시, 퍼사드, 컴포지트, 어댑터, 브리지, 플라이웨이트



# Ch14. 기타 패턴

## 1. 브리지 패턴

### 한 줄 개념 정리  
기능 계층과 구현 계층을 분리하여 각각 독립적으로 확장할 수 있도록 하는 구조 패턴

---

### 사용 시점  
- 기능과 구현이 모두 자주 변경될 가능성이 있을 때  
- 클래스 수가 기하급수적으로 증가하는 상속 구조를 피하고 싶을 때  
- 다양한 플랫폼/장치에 따라 구현을 분리하고 싶을 때  

---

### 시나리오 예시  
알림 시스템을 구현할 때, 알림 종류(에러, 정보, 경고 등)와 전송 수단(이메일, 슬랙, 문자 등)이 다양할 수 있다.  
이 둘을 직접 상속으로 연결하면 조합 수만큼 클래스가 필요해져 유지보수가 어렵다.  
브리지 패턴은 알림 기능과 전송 수단을 **분리**하여 독립적으로 개발하고, 런타임에 조합할 수 있도록 한다.


## 2. 빌더 패턴

### 한 줄 개념 정리  
복잡한 객체의 생성 과정을 분리하여, 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있도록 하는 생성 패턴

---

### 사용 시점  
- 생성자에 파라미터가 너무 많고, 그 중 일부만 필수일 경우  
- 생성 과정이 복잡하여, 가독성이 떨어지고 실수가 잦을 때  
- 동일한 객체를 다양한 방식으로 구성해야 할 때  

---

### 시나리오 예시  
`User` 객체를 생성할 때, 필수 정보는 `id`와 `name`뿐이지만 선택적으로 `age`, `email`, `phoneNumber` 등을 설정할 수 있다고 하자.  
기존 생성자로 처리하려면 너무 많은 생성자 오버로딩이 필요하거나, 무의미한 null값을 넣게 될 수 있다.  
➡ 빌더 패턴을 사용하면 필요한 정보만 명확하게 설정하면서 가독성을 높일 수 있다.

---

## 3. 책임 연쇄 패턴

### 한 줄 개념 정리  
요청을 처리할 수 있는 객체들을 체인 형태로 연결하고, 요청을 순차적으로 전달하며 처리 책임을 분산시키는 행동 패턴

---

### 사용 시점  
- 요청을 처리할 수 있는 객체가 여러 개 있고, **누가 처리할지 미리 결정할 수 없을 때**  
- 처리 객체를 동적으로 연결하고, 책임을 위임하고자 할 때  
- 조건에 따라 서로 다른 방식으로 요청을 처리할 수 있도록 하고 싶을 때  

---

### 시나리오 예시  
로그 시스템을 구현할 때, 로그의 레벨이 INFO, DEBUG, ERROR로 나뉘고 각기 다른 핸들러에서 처리해야 한다고 하자.  
요청을 각 로그 핸들러에게 전달하고, 조건에 맞는 핸들러가 처리하도록 하려면 if-else나 switch문이 반복될 수 있다.  
➡ 책임 연쇄 패턴을 사용하면 각 핸들러가 책임을 지고, 처리할 수 없으면 다음 핸들러에 전달하도록 깔끔하게 구성할 수 있다.

---

## 4. 플라이웨이트 패턴

### 한 줄 개념 정리  
공통 데이터를 공유하여 **메모리 사용을 최소화**하는 구조 패턴

---

### 사용 시점  
- 많은 수의 유사 객체가 반복적으로 생성될 때  
- 객체 생성 비용이 높고, 객체들이 동일한 데이터를 공유할 수 있을 때  
- 대량의 객체가 존재하되 일부 속성만 달라서 분리할 수 있을 때  

---

### 시나리오 예시  
문서 편집기에서 수천 개의 문자 객체를 생성해야 한다고 가정하자.  
문자마다 글자, 글꼴, 크기 등의 정보는 동일할 수 있지만, 위치 정보는 다르다.  
모든 정보를 가진 객체를 수천 개 만들면 메모리 낭비가 크다.  
➡ 플라이웨이트 패턴을 사용하면 **공통 속성은 공유**하고, **개별 속성만 외부에서 주입**하여 메모리 사용량을 줄일 수 있다.


## 5. 인터프리터 패턴

### 한 줄 개념 정리  
문법 규칙을 클래스 구조로 표현하고, 이를 해석할 수 있도록 만드는 행동 패턴

---

### 사용 시점  
- 언어나 표현식의 문법을 정의하고, 이를 해석하는 기능이 필요할 때  
- 반복적인 해석 작업이 요구되는 간단한 언어(예: 계산기, SQL, 정규식 등)를 구현하고자 할 때  
- 문법이 비교적 단순하며, 성능보다 유연성과 구조화된 표현이 중요할 때  

---

### 시나리오 예시  
간단한 수식 언어에서 `"1 + 2 + 3"` 같은 표현식을 해석해야 한다고 하자.  
문자열을 일일이 파싱하는 대신, 각 구성 요소를 객체로 추상화하면 표현식의 구조와 해석 방법을 명확히 분리할 수 있다.  
➡ 인터프리터 패턴을 사용하면 문법 구조를 클래스로 표현하고, 재귀적 구조로 구성된 표현식을 해석할 수 있다.


## 6. 중재자 패턴

### 한 줄 개념 정리  
객체 간의 복잡한 상호작용을 **중재자 객체**에 위임하여, 객체 간의 결합도를 낮추고 유연하게 관계를 관리하는 행동 패턴

---

### 사용 시점  
- 여러 객체가 서로 복잡하게 상호작용하는 상황에서  
- 객체 간 직접 통신을 피하고 싶을 때 (낮은 결합도 유지 목적)  
- 객체들의 통신 로직이 중복되거나 흩어져 있는 경우  

---

### 시나리오 예시  
채팅 프로그램을 만든다고 해보자. 사용자 A가 B, C, D에게 메시지를 보내야 할 때, 각각 직접 연결하면 각 사용자 클래스가 다른 사용자들의 정보를 알고 있어야 한다.  
➡ 중재자 패턴을 사용하면, 모든 통신을 **중재자(ChatRoom)**가 관리하고, 사용자 객체들은 오직 중재자만 알고 있으면 된다.  
이렇게 하면 사용자가 추가/삭제되더라도 다른 사용자 코드에는 영향이 없다.

---


## 7. 메멘토 패턴

### 한 줄 개념 정리  
객체의 내부 상태를 저장하고 복원할 수 있게 하여, 이전 상태로 되돌릴 수 있도록 하는 행동 패턴

---

### 사용 시점  
- 실행 취소(undo) 기능이 필요한 경우  
- 객체의 상태를 외부에 노출하지 않고 저장 및 복원이 필요한 경우  
- 게임 저장, 문서 편집기 등 상태 복원이 자주 발생하는 프로그램에서  

---

### 시나리오 예시  
텍스트 에디터를 만든다고 해보자. 사용자가 문서를 작성하다가 '되돌리기(Undo)' 버튼을 누르면 이전 상태로 돌아가야 한다.  
객체의 상태를 외부에서 직접 접근하지 않고 저장하고 복원하려면 상태 정보를 안전하게 보존해야 한다.  
➡ 메멘토 패턴을 사용하면 **상태를 캡슐화**하여, **관리자(Caretaker)**가 저장하고, 필요할 때 복원할 수 있다.

---

## 8. 프로토타입 패턴

### 한 줄 개념 정리  
새로운 객체를 생성할 때, 기존 객체를 복사(clone)하여 사용하는 생성 패턴

---

### 사용 시점  
- 객체 생성 비용이 크거나 복잡할 때  
- 비슷한 객체를 여러 개 반복적으로 생성해야 할 때  
- 런타임에 객체의 구체적인 타입을 알 수 없을 때  

---

### 시나리오 예시  
게임에서 몬스터 객체를 매번 복잡한 설정을 통해 생성하면 부담이 크다.  
➡ 기본이 되는 몬스터 객체를 하나 만들어두고, 이를 복사해서 다양한 인스턴스를 만들면 코드가 단순하고 성능도 향상된다.  
또한, 구성 방식이 유연하여 팩토리 패턴과도 함께 쓰일 수 있다.

---


## 9. 비지터 패턴

### 한 줄 개념 정리  
객체 구조는 그대로 두고, 구조 안의 요소에 대해 **새로운 동작을 추가할 수 있도록** 하는 행동 패턴

---

### 사용 시점  
- 객체 구조는 자주 변경되지 않지만, 그 내부 요소에 대해 **다양한 연산을 자주 추가해야 할 때**  
- 연산을 객체 외부에서 정의하여, **열린-폐쇄 원칙(Open-Closed Principle)**을 지키고 싶을 때  
- 객체 타입에 따라 다르게 처리해야 할 연산이 많을 때  

---

### 시나리오 예시  
파일 시스템처럼 다양한 요소(파일, 폴더 등)를 트리 구조로 관리하고 있다고 하자.  
각 요소마다 "크기 계산", "백업", "압축" 등의 동작이 존재하는데, 이걸 각 클래스 내부에 넣으면 코드가 복잡해지고 중복된다.  
➡ 비지터 패턴을 사용하면, 요소 객체는 그대로 두고, **연산을 외부에서 따로 관리**할 수 있어 유지보수성이 좋아진다.

---
